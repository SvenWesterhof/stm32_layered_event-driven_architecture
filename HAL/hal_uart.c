/**
 * @file hal_uart.c
 * @brief UART Hardware Abstraction Layer Implementation
 *
 * Implements UART abstraction using STM32 HAL UART driver.
 * Supports hardware flow control, DMA, and event-driven reception.
 */

#include "hal_uart.h"
#include "stm32f7xx_hal.h"
#include "../Drivers_BSP/Custom/portable_log.h"
#include "../OS/os_wrapper.h"
#include <string.h>

static const char *TAG = "HAL_UART";

#define UART_EVENT_QUEUE_SIZE   20
#define UART_EVENT_TASK_STACK   2048
#define UART_RX_DMA_BUFFER_SIZE 256

/**
 * @brief Internal state for each UART port
 */
typedef struct {
    bool initialized;
    UART_HandleTypeDef *huart;
    os_queue_handle_t event_queue;
    os_task_handle_t event_task;
    hal_uart_event_callback_t callback;
    void *user_data;
    uint8_t *rx_buffer;
    size_t rx_buffer_size;
    volatile size_t rx_write_pos;
    volatile size_t rx_read_pos;
    uint8_t rx_dma_buffer[UART_RX_DMA_BUFFER_SIZE];
    size_t last_rx_dma_pos;
    volatile bool tx_in_progress;  // Flag for async TX
} hal_uart_state_t;

static hal_uart_state_t uart_state[HAL_UART_PORT_MAX] = {0};

// External UART handles (should be defined in main.c or generated by CubeMX)
// Only declare the UARTs that are actually configured in CubeMX
extern UART_HandleTypeDef huart2;  // USART2 is configured

/**
 * @brief Get STM32 UART handle for a port
 */
static UART_HandleTypeDef* get_uart_handle(hal_uart_port_t port)
{
    switch (port) {
        case HAL_UART_PORT_0: return NULL;  // USART1 not configured
        case HAL_UART_PORT_1: return &huart2;  // USART2 configured
        case HAL_UART_PORT_2: return NULL;  // USART3 not configured
        default: return NULL;
    }
}

/**
 * @brief Convert HAL parity to STM32 parity
 */
static uint32_t convert_parity(hal_uart_parity_t parity)
{
    switch (parity) {
        case HAL_UART_PARITY_EVEN: return UART_PARITY_EVEN;
        case HAL_UART_PARITY_ODD:  return UART_PARITY_ODD;
        default:                   return UART_PARITY_NONE;
    }
}

/**
 * @brief Convert HAL stop bits to STM32 stop bits
 */
static uint32_t convert_stop_bits(hal_uart_stop_bits_t stop_bits)
{
    switch (stop_bits) {
        case HAL_UART_STOP_BITS_1_5: return UART_STOPBITS_1_5;
        case HAL_UART_STOP_BITS_2:   return UART_STOPBITS_2;
        default:                      return UART_STOPBITS_1;
    }
}

/**
 * @brief Convert HAL flow control to STM32 flow control
 */
static uint32_t convert_flow_ctrl(hal_uart_flow_ctrl_t flow_ctrl)
{
    switch (flow_ctrl) {
        case HAL_UART_FLOW_CTRL_RTS:     return UART_HWCONTROL_RTS;
        case HAL_UART_FLOW_CTRL_CTS:     return UART_HWCONTROL_CTS;
        case HAL_UART_FLOW_CTRL_RTS_CTS: return UART_HWCONTROL_RTS_CTS;
        default:                          return UART_HWCONTROL_NONE;
    }
}

/**
 * @brief Convert HAL data bits to STM32 word length
 */
static uint32_t convert_data_bits(uint8_t data_bits)
{
    switch (data_bits) {
        case 7: return UART_WORDLENGTH_7B;
        case 9: return UART_WORDLENGTH_9B;
        default: return UART_WORDLENGTH_8B;
    }
}

/**
 * @brief Calculate buffer available bytes
 */
static size_t buffer_available(hal_uart_state_t *state)
{
    size_t write_pos = state->rx_write_pos;
    size_t read_pos = state->rx_read_pos;

    if (write_pos >= read_pos) {
        return write_pos - read_pos;
    } else {
        return state->rx_buffer_size - read_pos + write_pos;
    }
}

/**
 * @brief Write data to RX ring buffer
 */
static size_t buffer_write(hal_uart_state_t *state, const uint8_t *data, size_t len)
{
    if (state->rx_buffer == NULL) {
        return 0;
    }

    size_t written = 0;
    size_t write_pos = state->rx_write_pos;
    size_t read_pos = state->rx_read_pos;

    for (size_t i = 0; i < len; i++) {
        size_t next_write_pos = (write_pos + 1) % state->rx_buffer_size;

        // Check if buffer is full
        if (next_write_pos == read_pos) {
            // Buffer overflow - trigger event
            hal_uart_event_t event = {
                .type = HAL_UART_EVENT_RX_OVERFLOW,
                .size = 0
            };
            if (state->event_queue) {
                os_queue_send(state->event_queue, &event, OS_NO_WAIT);
            }
            break;
        }

        state->rx_buffer[write_pos] = data[i];
        write_pos = next_write_pos;
        written++;
    }

    state->rx_write_pos = write_pos;
    return written;
}

/**
 * @brief Read data from RX ring buffer
 */
static size_t buffer_read(hal_uart_state_t *state, uint8_t *data, size_t len)
{
    if (state->rx_buffer == NULL) {
        return 0;
    }

    size_t read = 0;
    size_t write_pos = state->rx_write_pos;
    size_t read_pos = state->rx_read_pos;

    while (read < len && read_pos != write_pos) {
        data[read++] = state->rx_buffer[read_pos];
        read_pos = (read_pos + 1) % state->rx_buffer_size;
    }

    state->rx_read_pos = read_pos;
    return read;
}

/**
 * @brief Process DMA reception - called periodically
 */
static void process_dma_rx(hal_uart_port_t port)
{
    hal_uart_state_t *state = &uart_state[port];

    if (!state->initialized || state->huart == NULL) {
        return;
    }

    // Get current DMA position
    size_t current_pos = UART_RX_DMA_BUFFER_SIZE - __HAL_DMA_GET_COUNTER(state->huart->hdmarx);
    size_t last_pos = state->last_rx_dma_pos;

    if (current_pos != last_pos) {
        size_t received;

        if (current_pos > last_pos) {
            // Normal case: DMA hasn't wrapped
            received = current_pos - last_pos;
            buffer_write(state, &state->rx_dma_buffer[last_pos], received);
        } else {
            // DMA wrapped around
            size_t to_end = UART_RX_DMA_BUFFER_SIZE - last_pos;
            buffer_write(state, &state->rx_dma_buffer[last_pos], to_end);
            buffer_write(state, state->rx_dma_buffer, current_pos);
            received = to_end + current_pos;
        }

        state->last_rx_dma_pos = current_pos;

        // Trigger RX data event
        if (received > 0 && state->callback) {
            hal_uart_event_t event = {
                .type = HAL_UART_EVENT_RX_DATA,
                .size = received
            };
            if (state->event_queue) {
                os_queue_send(state->event_queue, &event, OS_NO_WAIT);
            }
        }
    }
}

/**
 * @brief UART event processing task
 */
static void uart_event_task(void *arg)
{
    hal_uart_port_t port = (hal_uart_port_t)(uintptr_t)arg;
    hal_uart_event_t event;
    uint32_t last_wake_time = os_get_tick_count();

    while (1) {
        // Poll DMA buffer periodically
        process_dma_rx(port);

        // Process queued events
        while (os_queue_receive(uart_state[port].event_queue, &event, OS_NO_WAIT) == OS_SUCCESS) {
            if (uart_state[port].callback != NULL) {
                uart_state[port].callback(port, &event, uart_state[port].user_data);
            }
        }

        // Sleep for 10ms
        uint32_t current_time = os_get_tick_count();
        uint32_t elapsed = current_time - last_wake_time;
        uint32_t sleep_ticks = os_ms_to_ticks(10);

        if (elapsed < sleep_ticks) {
            os_delay_ms(os_ticks_to_ms(sleep_ticks - elapsed));
        }

        last_wake_time = current_time;
    }
}

bool hal_uart_init(hal_uart_port_t port, const hal_uart_config_t *config)
{
    if (port >= HAL_UART_PORT_MAX || config == NULL) {
        LOG_E(TAG, "Invalid parameters");
        return false;
    }

    if (uart_state[port].initialized) {
        LOG_W(TAG, "UART%d already initialized", port);
        return false;
    }

    UART_HandleTypeDef *huart = get_uart_handle(port);
    if (huart == NULL) {
        LOG_E(TAG, "UART%d handle not available", port);
        return false;
    }

    LOG_I(TAG, "Initializing UART%d (baud=%lu)", port, (unsigned long)config->baud_rate);

    // Configure UART parameters
    huart->Init.BaudRate = config->baud_rate;
    huart->Init.WordLength = convert_data_bits(config->data_bits);
    huart->Init.StopBits = convert_stop_bits(config->stop_bits);
    huart->Init.Parity = convert_parity(config->parity);
    huart->Init.Mode = UART_MODE_TX_RX;
    huart->Init.HwFlowCtl = convert_flow_ctrl(config->flow_ctrl);
    huart->Init.OverSampling = UART_OVERSAMPLING_16;

    if (HAL_UART_Init(huart) != HAL_OK) {
        LOG_E(TAG, "UART%d initialization failed", port);
        return false;
    }

    // Allocate RX buffer
    size_t rx_buf_size = config->rx_buffer_size > 0 ? config->rx_buffer_size : 1024;
    uart_state[port].rx_buffer = (uint8_t*)malloc(rx_buf_size);
    if (uart_state[port].rx_buffer == NULL) {
        LOG_E(TAG, "UART%d RX buffer allocation failed", port);
        HAL_UART_DeInit(huart);
        return false;
    }

    uart_state[port].rx_buffer_size = rx_buf_size;
    uart_state[port].rx_write_pos = 0;
    uart_state[port].rx_read_pos = 0;
    uart_state[port].last_rx_dma_pos = 0;

    // Create event queue
    uart_state[port].event_queue = os_queue_create(UART_EVENT_QUEUE_SIZE, sizeof(hal_uart_event_t));
    if (uart_state[port].event_queue == NULL) {
        LOG_E(TAG, "UART%d event queue creation failed", port);
        free(uart_state[port].rx_buffer);
        HAL_UART_DeInit(huart);
        return false;
    }

    // Create event processing task
    char task_name[16];
    snprintf(task_name, sizeof(task_name), "uart%d_evt", port);

    os_result_t ret = os_task_create(uart_event_task, task_name,
                                     UART_EVENT_TASK_STACK, (void *)(uintptr_t)port,
                                     OS_PRIORITY_HIGH, &uart_state[port].event_task);
    if (ret != OS_SUCCESS) {
        LOG_E(TAG, "UART%d event task create failed", port);
        os_queue_delete(uart_state[port].event_queue);
        free(uart_state[port].rx_buffer);
        HAL_UART_DeInit(huart);
        return false;
    }

    // Start DMA reception in circular mode
    HAL_UART_Receive_DMA(huart, uart_state[port].rx_dma_buffer, UART_RX_DMA_BUFFER_SIZE);

    uart_state[port].initialized = true;
    uart_state[port].huart = huart;
    uart_state[port].callback = NULL;
    uart_state[port].user_data = NULL;

    LOG_I(TAG, "UART%d initialized successfully", port);
    return true;
}

bool hal_uart_deinit(hal_uart_port_t port)
{
    if (port >= HAL_UART_PORT_MAX) {
        return false;
    }

    if (!uart_state[port].initialized) {
        return true;
    }

    // Stop DMA
    if (uart_state[port].huart != NULL) {
        HAL_UART_DMAStop(uart_state[port].huart);
        HAL_UART_DeInit(uart_state[port].huart);
    }

    // Delete event task
    if (uart_state[port].event_task) {
        os_task_delete(uart_state[port].event_task);
        uart_state[port].event_task = NULL;
    }

    // Delete event queue
    if (uart_state[port].event_queue) {
        os_queue_delete(uart_state[port].event_queue);
        uart_state[port].event_queue = NULL;
    }

    // Free RX buffer
    if (uart_state[port].rx_buffer) {
        free(uart_state[port].rx_buffer);
        uart_state[port].rx_buffer = NULL;
    }

    uart_state[port].initialized = false;
    uart_state[port].huart = NULL;
    uart_state[port].callback = NULL;
    uart_state[port].user_data = NULL;

    LOG_I(TAG, "UART%d deinitialized", port);
    return true;
}

int hal_uart_write(hal_uart_port_t port, const uint8_t *data, size_t len, int timeout_ms)
{
    if (port >= HAL_UART_PORT_MAX || !uart_state[port].initialized) {
        return -1;
    }

    if (data == NULL || len == 0) {
        return 0;
    }

    UART_HandleTypeDef *huart = uart_state[port].huart;
    uint32_t timeout = (timeout_ms < 0) ? HAL_MAX_DELAY : timeout_ms;

    HAL_StatusTypeDef status = HAL_UART_Transmit(huart, (uint8_t*)data, len, timeout);

    if (status == HAL_OK) {
        return (int)len;
    } else if (status == HAL_TIMEOUT) {
        return 0;
    } else {
        return -1;
    }
}

bool hal_uart_write_async(hal_uart_port_t port, const uint8_t *data, size_t len)
{
    if (port >= HAL_UART_PORT_MAX || !uart_state[port].initialized) {
        LOG_E(TAG, "UART%d not initialized", port);
        return false;
    }

    if (data == NULL || len == 0) {
        LOG_E(TAG, "UART%d invalid parameters", port);
        return false;
    }

    // Check if transmission is already in progress
    if (uart_state[port].tx_in_progress) {
        LOG_W(TAG, "UART%d TX already in progress", port);
        return false;
    }

    UART_HandleTypeDef *huart = uart_state[port].huart;

    // Start DMA transmission
    HAL_StatusTypeDef status = HAL_UART_Transmit_DMA(huart, (uint8_t*)data, len);

    if (status != HAL_OK) {
        LOG_E(TAG, "UART%d DMA TX start failed: %d", port, status);
        return false;
    }

    uart_state[port].tx_in_progress = true;
    return true;
}

int hal_uart_read(hal_uart_port_t port, uint8_t *data, size_t len, int timeout_ms)
{
    if (port >= HAL_UART_PORT_MAX || !uart_state[port].initialized) {
        return -1;
    }

    if (data == NULL || len == 0) {
        return 0;
    }

    hal_uart_state_t *state = &uart_state[port];
    uint32_t start_time = os_get_time_ms();
    uint32_t timeout_time = (timeout_ms < 0) ? 0xFFFFFFFF : start_time + timeout_ms;

    size_t total_read = 0;

    while (total_read < len) {
        // Process any new DMA data
        process_dma_rx(port);

        // Try to read from buffer
        size_t read = buffer_read(state, data + total_read, len - total_read);
        total_read += read;

        if (total_read >= len) {
            break;
        }

        // Check timeout
        if (timeout_ms >= 0) {
            uint32_t current_time = os_get_time_ms();
            if (current_time >= timeout_time) {
                break;
            }
        }

        // Wait a bit before trying again
        os_delay_ms(1);
    }

    return (int)total_read;
}

int hal_uart_available(hal_uart_port_t port)
{
    if (port >= HAL_UART_PORT_MAX || !uart_state[port].initialized) {
        return -1;
    }

    // Process any new DMA data first
    process_dma_rx(port);

    return (int)buffer_available(&uart_state[port]);
}

bool hal_uart_flush_tx(hal_uart_port_t port, int timeout_ms)
{
    if (port >= HAL_UART_PORT_MAX || !uart_state[port].initialized) {
        return false;
    }

    // STM32 HAL transmit is already blocking, so TX is flushed after transmission
    return true;
}

bool hal_uart_flush_rx(hal_uart_port_t port)
{
    if (port >= HAL_UART_PORT_MAX || !uart_state[port].initialized) {
        return false;
    }

    hal_uart_state_t *state = &uart_state[port];

    // Reset buffer pointers
    state->rx_write_pos = 0;
    state->rx_read_pos = 0;

    // Reset event queue
    if (state->event_queue) {
        os_queue_reset(state->event_queue);
    }

    return true;
}

bool hal_uart_register_callback(hal_uart_port_t port,
                                 hal_uart_event_callback_t callback,
                                 void *user_data)
{
    if (port >= HAL_UART_PORT_MAX || !uart_state[port].initialized) {
        return false;
    }

    uart_state[port].callback = callback;
    uart_state[port].user_data = user_data;
    return true;
}

bool hal_uart_unregister_callback(hal_uart_port_t port)
{
    if (port >= HAL_UART_PORT_MAX) {
        return false;
    }

    uart_state[port].callback = NULL;
    uart_state[port].user_data = NULL;
    return true;
}

bool hal_uart_set_baudrate(hal_uart_port_t port, uint32_t baud_rate)
{
    if (port >= HAL_UART_PORT_MAX || !uart_state[port].initialized) {
        return false;
    }

    UART_HandleTypeDef *huart = uart_state[port].huart;

    // Stop DMA temporarily
    HAL_UART_DMAStop(huart);

    // Update baud rate
    huart->Init.BaudRate = baud_rate;

    if (HAL_UART_Init(huart) != HAL_OK) {
        LOG_E(TAG, "UART%d set baudrate failed", port);
        return false;
    }

    // Restart DMA reception
    uart_state[port].last_rx_dma_pos = 0;
    HAL_UART_Receive_DMA(huart, uart_state[port].rx_dma_buffer, UART_RX_DMA_BUFFER_SIZE);

    LOG_I(TAG, "UART%d baudrate set to %lu", port, (unsigned long)baud_rate);
    return true;
}

hal_uart_config_t hal_uart_get_default_config(void)
{
    hal_uart_config_t config = {
        .baud_rate = 115200,
        .data_bits = 8,
        .parity = HAL_UART_PARITY_NONE,
        .stop_bits = HAL_UART_STOP_BITS_1,
        .flow_ctrl = HAL_UART_FLOW_CTRL_NONE,
        .tx_pin = -1,
        .rx_pin = -1,
        .rts_pin = -1,
        .cts_pin = -1,
        .rx_buffer_size = 1024,
        .tx_buffer_size = 0,  // Blocking TX by default
    };
    return config;
}

/**
 * @brief UART error callback - can be called from STM32 HAL
 */
void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
{
    // Find which port this UART belongs to
    hal_uart_port_t port;
    for (port = HAL_UART_PORT_0; port < HAL_UART_PORT_MAX; port++) {
        if (uart_state[port].huart == huart) {
            break;
        }
    }

    if (port >= HAL_UART_PORT_MAX || !uart_state[port].initialized) {
        return;
    }

    hal_uart_event_t event = {0};
    uint32_t error = HAL_UART_GetError(huart);

    if (error & HAL_UART_ERROR_PE) {
        event.type = HAL_UART_EVENT_PARITY_ERROR;
        LOG_W(TAG, "UART%d parity error", port);
    } else if (error & HAL_UART_ERROR_FE) {
        event.type = HAL_UART_EVENT_FRAME_ERROR;
        LOG_W(TAG, "UART%d frame error", port);
    } else if (error & HAL_UART_ERROR_ORE) {
        event.type = HAL_UART_EVENT_RX_OVERFLOW;
        LOG_W(TAG, "UART%d overrun error", port);
    } else {
        return; // Ignore other errors
    }

    if (uart_state[port].event_queue) {
        os_queue_send(uart_state[port].event_queue, &event, OS_NO_WAIT);
    }
}

/**
 * @brief UART TX complete callback - called from STM32 HAL when DMA TX completes
 */
void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
    // Find which port this UART belongs to
    hal_uart_port_t port;
    for (port = HAL_UART_PORT_0; port < HAL_UART_PORT_MAX; port++) {
        if (uart_state[port].huart == huart) {
            break;
        }
    }

    if (port >= HAL_UART_PORT_MAX || !uart_state[port].initialized) {
        return;
    }

    // Clear TX in progress flag
    uart_state[port].tx_in_progress = false;

    // Trigger TX done event if callback is registered
    if (uart_state[port].callback) {
        hal_uart_event_t event = {
            .type = HAL_UART_EVENT_TX_DONE,
            .size = 0
        };
        if (uart_state[port].event_queue) {
            os_queue_send(uart_state[port].event_queue, &event, OS_NO_WAIT);
        }
    }
}
